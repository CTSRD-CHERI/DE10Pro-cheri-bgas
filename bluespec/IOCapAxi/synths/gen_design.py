import argparse
import math
import os
import re
import sys

SPECIAL_INPUTS = ["CLK", "RST_N"]

INPUT = re.compile(r"input\s+(\[(\d+)\s*:\s*0\]\s+)?(\w+);")
OUTPUT = re.compile(r"output\s+(\[(\d+)\s*:\s*0\]\s+)?(\w+);")

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("ifc", help=".txt file ")

    args = parser.parse_args()

    ifc_name = os.path.basename(args.ifc).removesuffix(".txt")
    ifc_inputs = []
    ifc_outputs = []

    with open(args.ifc, "r") as f:
        for line in f:
            if not line.strip():
                continue
            input_m = INPUT.match(line)
            if input_m:
                signal_name = input_m.group(3)
                if signal_name in SPECIAL_INPUTS:
                    print(f"Ignoring special input {signal_name}", file=sys.stderr)
                    continue
                width = (int(input_m.group(2)) + 1) if input_m.group(2) is not None else 1
                ifc_inputs.append((signal_name, width))
                continue
            output_m = OUTPUT.match(line)
            if output_m:
                signal_name = output_m.group(3)
                width = (int(output_m.group(2)) + 1) if output_m.group(2) is not None else 1
                ifc_outputs.append((signal_name, width))
                continue

            raise RuntimeError(f"Line '{line}' doesn't match either input or output")
        
    overall_input_width = sum(w for (name, w) in ifc_inputs)
    overall_output_width = sum(w for (name, w) in ifc_outputs)
    assert overall_input_width != 0
    assert overall_output_width != 0
    
    # https://stackoverflow.com/a/14267825
    padded_output_lg2 = math.ceil(math.log(overall_output_width, 2))
    padded_output_width = 2 ** padded_output_lg2

    prefix = f"""
// Generated by gen_design.py from {args.ifc}
// Expects `DUT to be defined as a design fitting the {ifc_name} Bluespec interface
module {ifc_name}_design(
    input CLK_SLOW,
    input CLK_FAST,
    input RST_N,
    input pin_in,
    input pin_out
);
    wire[{overall_input_width}-1:0] dut_in;
    wire[{padded_output_width}-1:0] dut_out;

    input_harness#(.BITS({overall_input_width})) i(
        .slow_clk(CLK_SLOW),
        .fast_clk(CLK_FAST),
        .rst_n(RST_N),
        .pin_on_slow_clk(pin_in),
        .data_on_fast_clk(dut_in)
    );

    output_harness#(.BITS({padded_output_width}), .LG_BITS({padded_output_lg2})) o(
        .slow_clk(CLK_SLOW),
        .fast_clk(CLK_FAST),
        .rst_n(RST_N),
        .data_on_fast_clk(dut_out),
        .pin_on_slow_clk(pin_out)
    );

    `DUT dut(
        .CLK(CLK_FAST),
        .RST_N(RST_N),
"""
    suffix = f"""
    );
endmodule
"""
    print(prefix)

    first = True
    curr_input_start_bit = 0
    for (name, width) in ifc_inputs:
        if not first:
            print(f",")
        if width == 1:
            print(f"        .{name}(dut_in[{curr_input_start_bit}])", end='')
        else:
            print(f"        .{name}(dut_in[{curr_input_start_bit+width-1}:{curr_input_start_bit}])", end='')
        curr_input_start_bit += width
        first = False

    curr_output_start_bit = 0
    for (name, width) in ifc_outputs:
        if not first:
            print(f",")
        if width == 1:
            print(f"        .{name}(dut_out[{curr_output_start_bit}])", end='')
        else:
            print(f"        .{name}(dut_out[{curr_output_start_bit+width-1}:{curr_output_start_bit}])", end='')
        curr_output_start_bit += width
        first = False

    print(suffix)
    