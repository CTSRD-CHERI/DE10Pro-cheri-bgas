// Autogenerated by generate_bitfield.py
// Requires <cstdint> and <array>, does not include them by default because this file may be included inside of a namespace

struct AWFlit_id4_addr64_user3 {
	/** 4-bit field */
	uint8_t awid;
	/** 64-bit field */
	uint64_t awaddr;
	/** 8-bit field */
	uint8_t awlen;
	/** 3-bit field */
	uint8_t awsize;
	/** 2-bit field */
	uint8_t awburst;
	/** 1-bit field */
	uint8_t awlock;
	/** 4-bit field */
	uint8_t awcache;
	/** 3-bit field */
	uint8_t awprot;
	/** 4-bit field */
	uint8_t awqos;
	/** 8-bit field */
	uint8_t awregion;
	/** 3-bit field */
	uint8_t awuser;

	static AWFlit_id4_addr64_user3 unpack(const std::array<uint32_t, 4>& backing) {
		AWFlit_id4_addr64_user3 value{};
		value.awid = (
			uint8_t((backing[0] >> 0u) & 0xfu)
		);
		value.awaddr = (
			(uint64_t((backing[0] >> 4u) & 0xfffffffu) << 0) | 
			(uint64_t((backing[1] >> 0u) & 0xffffffffu) << 28) | 
			(uint64_t((backing[2] >> 0u) & 0xfu) << 60)
		);
		value.awlen = (
			uint8_t((backing[2] >> 4u) & 0xffu)
		);
		value.awsize = (
			uint8_t((backing[2] >> 12u) & 0x7u)
		);
		value.awburst = (
			uint8_t((backing[2] >> 15u) & 0x3u)
		);
		value.awlock = (
			uint8_t((backing[2] >> 17u) & 0x1u)
		);
		value.awcache = (
			uint8_t((backing[2] >> 18u) & 0xfu)
		);
		value.awprot = (
			uint8_t((backing[2] >> 22u) & 0x7u)
		);
		value.awqos = (
			uint8_t((backing[2] >> 25u) & 0xfu)
		);
		value.awregion = (
			(uint8_t((backing[2] >> 29u) & 0x7u) << 0) | 
			(uint8_t((backing[3] >> 0u) & 0x1fu) << 3)
		);
		value.awuser = (
			uint8_t((backing[3] >> 5u) & 0x7u)
		);
		return value;
	}
	std::array<uint32_t, 4> pack() const {
		std::array<uint32_t, 4> backing{};
		backing[0] = (
			(uint32_t((awid >> 0u) & uint8_t(0xful)) << 0) | 
			(uint32_t((awaddr >> 0u) & 0xffffffful) << 4)
		);
		backing[1] = (
			uint32_t((awaddr >> 28u) & 0xfffffffful)
		);
		backing[2] = (
			(uint32_t((awaddr >> 60u) & 0xful) << 0) | 
			(uint32_t((awlen >> 0u) & uint8_t(0xfful)) << 4) | 
			(uint32_t((awsize >> 0u) & uint8_t(0x7ul)) << 12) | 
			(uint32_t((awburst >> 0u) & uint8_t(0x3ul)) << 15) | 
			(uint32_t((awlock >> 0u) & uint8_t(0x1ul)) << 17) | 
			(uint32_t((awcache >> 0u) & uint8_t(0xful)) << 18) | 
			(uint32_t((awprot >> 0u) & uint8_t(0x7ul)) << 22) | 
			(uint32_t((awqos >> 0u) & uint8_t(0xful)) << 25) | 
			(uint32_t((awregion >> 0u) & uint8_t(0x7ul)) << 29)
		);
		backing[3] = (
			(uint32_t((awregion >> 3u) & uint8_t(0x1ful)) << 0) | 
			(uint32_t((awuser >> 0u) & uint8_t(0x7ul)) << 5)
		);
		return backing;
	}
	
};

struct WFlit_data32 {
	/** 32-bit field */
	uint32_t wdata;
	/** 4-bit field */
	uint8_t wstrb;
	/** 1-bit field */
	uint8_t wlast;

	static WFlit_data32 unpack(const uint64_t& backing) {
		WFlit_data32 value{};
		value.wdata = (
			uint32_t((backing >> 0u) & 0xfffffffful)
		);
		value.wstrb = (
			uint8_t((backing >> 32u) & 0xful)
		);
		value.wlast = (
			uint8_t((backing >> 36u) & 0x1ul)
		);
		return value;
	}
	uint64_t pack() const {
		uint64_t backing{};
		backing = (
			(uint64_t((wdata >> 0u) & 0xffffffffu) << 0) | 
			(uint64_t((wstrb >> 0u) & uint8_t(0xful)) << 32) | 
			(uint64_t((wlast >> 0u) & uint8_t(0x1ul)) << 36)
		);
		return backing;
	}
	
};

struct BFlit_id4 {
	/** 4-bit field */
	uint8_t bid;
	/** 2-bit field */
	uint8_t bresp;

	static BFlit_id4 unpack(const uint8_t& backing) {
		BFlit_id4 value{};
		value.bid = (
			((backing >> 0u) & uint8_t(0xful))
		);
		value.bresp = (
			((backing >> 4u) & uint8_t(0x3ul))
		);
		return value;
	}
	uint8_t pack() const {
		uint8_t backing{};
		backing = (
			(((bid >> 0u) & uint8_t(0xful)) << 0) | 
			(((bresp >> 0u) & uint8_t(0x3ul)) << 4)
		);
		return backing;
	}
	
};

struct ARFlit_id4_addr64_user3 {
	/** 4-bit field */
	uint8_t arid;
	/** 64-bit field */
	uint64_t araddr;
	/** 8-bit field */
	uint8_t arlen;
	/** 3-bit field */
	uint8_t arsize;
	/** 2-bit field */
	uint8_t arburst;
	/** 1-bit field */
	uint8_t arlock;
	/** 4-bit field */
	uint8_t arcache;
	/** 3-bit field */
	uint8_t arprot;
	/** 4-bit field */
	uint8_t arqos;
	/** 8-bit field */
	uint8_t arregion;
	/** 3-bit field */
	uint8_t aruser;

	static ARFlit_id4_addr64_user3 unpack(const std::array<uint32_t, 4>& backing) {
		ARFlit_id4_addr64_user3 value{};
		value.arid = (
			uint8_t((backing[0] >> 0u) & 0xfu)
		);
		value.araddr = (
			(uint64_t((backing[0] >> 4u) & 0xfffffffu) << 0) | 
			(uint64_t((backing[1] >> 0u) & 0xffffffffu) << 28) | 
			(uint64_t((backing[2] >> 0u) & 0xfu) << 60)
		);
		value.arlen = (
			uint8_t((backing[2] >> 4u) & 0xffu)
		);
		value.arsize = (
			uint8_t((backing[2] >> 12u) & 0x7u)
		);
		value.arburst = (
			uint8_t((backing[2] >> 15u) & 0x3u)
		);
		value.arlock = (
			uint8_t((backing[2] >> 17u) & 0x1u)
		);
		value.arcache = (
			uint8_t((backing[2] >> 18u) & 0xfu)
		);
		value.arprot = (
			uint8_t((backing[2] >> 22u) & 0x7u)
		);
		value.arqos = (
			uint8_t((backing[2] >> 25u) & 0xfu)
		);
		value.arregion = (
			(uint8_t((backing[2] >> 29u) & 0x7u) << 0) | 
			(uint8_t((backing[3] >> 0u) & 0x1fu) << 3)
		);
		value.aruser = (
			uint8_t((backing[3] >> 5u) & 0x7u)
		);
		return value;
	}
	std::array<uint32_t, 4> pack() const {
		std::array<uint32_t, 4> backing{};
		backing[0] = (
			(uint32_t((arid >> 0u) & uint8_t(0xful)) << 0) | 
			(uint32_t((araddr >> 0u) & 0xffffffful) << 4)
		);
		backing[1] = (
			uint32_t((araddr >> 28u) & 0xfffffffful)
		);
		backing[2] = (
			(uint32_t((araddr >> 60u) & 0xful) << 0) | 
			(uint32_t((arlen >> 0u) & uint8_t(0xfful)) << 4) | 
			(uint32_t((arsize >> 0u) & uint8_t(0x7ul)) << 12) | 
			(uint32_t((arburst >> 0u) & uint8_t(0x3ul)) << 15) | 
			(uint32_t((arlock >> 0u) & uint8_t(0x1ul)) << 17) | 
			(uint32_t((arcache >> 0u) & uint8_t(0xful)) << 18) | 
			(uint32_t((arprot >> 0u) & uint8_t(0x7ul)) << 22) | 
			(uint32_t((arqos >> 0u) & uint8_t(0xful)) << 25) | 
			(uint32_t((arregion >> 0u) & uint8_t(0x7ul)) << 29)
		);
		backing[3] = (
			(uint32_t((arregion >> 3u) & uint8_t(0x1ful)) << 0) | 
			(uint32_t((aruser >> 0u) & uint8_t(0x7ul)) << 5)
		);
		return backing;
	}
	
};

struct RFlit_id4_data32 {
	/** 4-bit field */
	uint8_t rid;
	/** 32-bit field */
	uint32_t rdata;
	/** 2-bit field */
	uint8_t rresp;
	/** 1-bit field */
	uint8_t rlast;

	static RFlit_id4_data32 unpack(const uint64_t& backing) {
		RFlit_id4_data32 value{};
		value.rid = (
			uint8_t((backing >> 0u) & 0xful)
		);
		value.rdata = (
			uint32_t((backing >> 4u) & 0xfffffffful)
		);
		value.rresp = (
			uint8_t((backing >> 36u) & 0x3ul)
		);
		value.rlast = (
			uint8_t((backing >> 38u) & 0x1ul)
		);
		return value;
	}
	uint64_t pack() const {
		uint64_t backing{};
		backing = (
			(uint64_t((rid >> 0u) & uint8_t(0xful)) << 0) | 
			(uint64_t((rdata >> 0u) & 0xffffffffu) << 4) | 
			(uint64_t((rresp >> 0u) & uint8_t(0x3ul)) << 36) | 
			(uint64_t((rlast >> 0u) & uint8_t(0x1ul)) << 38)
		);
		return backing;
	}
	
};

